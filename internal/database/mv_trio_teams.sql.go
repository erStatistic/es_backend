// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: mv_trio_teams.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCompMetricsByExactCWs = `-- name: GetCompMetricsByExactCWs :one
WITH
    want AS (
        SELECT
            ARRAY(
                SELECT
                    x
                FROM
                    unnest($3::INT[]) AS x
                ORDER BY
                    x
            ) AS cw_ids
    ),
    scope AS (
        SELECT
            game_team_id, game_code, started_at, game_rank, total_time, team_avg_mmr, cw_ids, cluster_ids
        FROM
            mv_trio_teams
        WHERE
            (
                $1::timestamptz IS NULL
                OR started_at >= $1
            )
            AND (
                $2::timestamptz IS NULL
                OR started_at < $2
            )
    ),
    scope_with_tier AS (
        SELECT
            s.game_team_id, s.game_code, s.started_at, s.game_rank, s.total_time, s.team_avg_mmr, s.cw_ids, s.cluster_ids,
            gt.gained_mmr
        FROM
            scope s
            JOIN game_teams gt ON gt.id = s.game_team_id
            LEFT JOIN tiers t ON s.team_avg_mmr <@ t.mmr_range
        WHERE
            (
                NULLIF($4, '') IS NULL
                OR t.name = $4
            )
    ),
    denom AS (
        SELECT
            COUNT(*)::float8 AS total_teams
        FROM
            scope_with_tier
    ),
    matched AS (
        SELECT
            s.game_team_id, s.game_code, s.started_at, s.game_rank, s.total_time, s.team_avg_mmr, s.cw_ids, s.cluster_ids, s.gained_mmr
        FROM
            scope_with_tier s,
            want w
        WHERE
            s.cw_ids = w.cw_ids
    ),
    agg AS (
        SELECT
            COUNT(*) AS team_count,
            SUM((game_rank = 1)::int) AS wins,
            AVG(gained_mmr)::float AS avg_mmr,
            AVG(total_time)::float AS avg_survival
        FROM
            matched
    )
SELECT
    w.cw_ids,
    a.team_count AS samples,
    a.wins,
    COALESCE(
        a.wins::float8 / NULLIF(a.team_count::float8, 0.0),
        0.0
    ) AS win_rate,
    COALESCE(
        a.team_count::float8 / NULLIF(d.total_teams, 0.0),
        0.0
    ) AS pick_rate,
    a.avg_mmr,
    a.avg_survival
FROM
    agg a
    CROSS JOIN denom d
    CROSS JOIN want w
WHERE
    a.team_count >= COALESCE(NULLIF($5::int, 0), 50)
`

type GetCompMetricsByExactCWsParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 []int32            `json:"column_3"`
	Column4 interface{}        `json:"column_4"`
	Column5 int32              `json:"column_5"`
}

type GetCompMetricsByExactCWsRow struct {
	CwIds       interface{} `json:"cw_ids"`
	Samples     int64       `json:"samples"`
	Wins        int64       `json:"wins"`
	WinRate     interface{} `json:"win_rate"`
	PickRate    interface{} `json:"pick_rate"`
	AvgMmr      float64     `json:"avg_mmr"`
	AvgSurvival float64     `json:"avg_survival"`
}

func (q *Queries) GetCompMetricsByExactCWs(ctx context.Context, arg GetCompMetricsByExactCWsParams) (GetCompMetricsByExactCWsRow, error) {
	row := q.db.QueryRow(ctx, getCompMetricsByExactCWs,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	var i GetCompMetricsByExactCWsRow
	err := row.Scan(
		&i.CwIds,
		&i.Samples,
		&i.Wins,
		&i.WinRate,
		&i.PickRate,
		&i.AvgMmr,
		&i.AvgSurvival,
	)
	return i, err
}

const getCompMetricsBySelectedCWs = `-- name: GetCompMetricsBySelectedCWs :one
WITH
    want AS (
        SELECT
            ARRAY(
                SELECT
                    cw.cluster_id
                FROM
                    character_weapons cw
                WHERE
                    cw.id = ANY ($3::INT[])
                ORDER BY
                    cw.cluster_id
            ) AS cluster_ids
    ),
    scope AS (
        SELECT
            game_team_id, game_code, started_at, game_rank, total_time, team_avg_mmr, cw_ids, cluster_ids
        FROM
            mv_trio_teams
        WHERE
            (
                $1::timestamptz IS NULL
                OR started_at >= $1
            )
            AND (
                $2::timestamptz IS NULL
                OR started_at < $2
            )
    ),
    scope_with_tier AS (
        SELECT
            s.game_team_id, s.game_code, s.started_at, s.game_rank, s.total_time, s.team_avg_mmr, s.cw_ids, s.cluster_ids,
            gt.gained_mmr
        FROM
            scope s
            JOIN game_teams gt ON gt.id = s.game_team_id
            LEFT JOIN tiers t ON s.team_avg_mmr <@ t.mmr_range
        WHERE
            (
                NULLIF($4, '') IS NULL
                OR t.name = $4
            )
    ),
    denom AS (
        SELECT
            COUNT(*)::float8 AS total_teams
        FROM
            scope_with_tier
    ),
    matched AS (
        SELECT
            s.game_team_id, s.game_code, s.started_at, s.game_rank, s.total_time, s.team_avg_mmr, s.cw_ids, s.cluster_ids, s.gained_mmr
        FROM
            scope_with_tier s,
            want w
        WHERE
            s.cluster_ids = w.cluster_ids
    ),
    agg AS (
        SELECT
            COUNT(*) AS team_count,
            SUM((game_rank = 1)::int) AS wins,
            AVG(gained_mmr)::float AS avg_mmr,
            AVG(total_time)::float AS avg_survival
        FROM
            matched
    ),
    label AS (
        SELECT
            ARRAY(
                SELECT
                    cid
                FROM
                    want w,
                    unnest(w.cluster_ids) cid
            ) AS cluster_ids,
            ARRAY_TO_STRING(
                ARRAY(
                    SELECT
                        cu.name
                    FROM
                        want w,
                        unnest(w.cluster_ids) cid
                        JOIN clusters cu ON cu.id = cid
                    ORDER BY
                        cu.name
                ),
                ' Â· '
            ) AS cluster_label
    )
SELECT
    l.cluster_ids,
    l.cluster_label,
    a.team_count AS samples,
    a.wins,
    COALESCE(
        a.wins::float8 / NULLIF(a.team_count::float8, 0.0),
        0.0
    ) AS win_rate,
    COALESCE(
        a.team_count::float8 / NULLIF(d.total_teams, 0.0),
        0.0
    ) AS pick_rate,
    a.avg_mmr,
    a.avg_survival
FROM
    agg a
    CROSS JOIN denom d
    CROSS JOIN label l
WHERE
    a.team_count >= COALESCE(NULLIF($5::int, 0), 50)
`

type GetCompMetricsBySelectedCWsParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 []int32            `json:"column_3"`
	Column4 interface{}        `json:"column_4"`
	Column5 int32              `json:"column_5"`
}

type GetCompMetricsBySelectedCWsRow struct {
	ClusterIds   interface{} `json:"cluster_ids"`
	ClusterLabel string      `json:"cluster_label"`
	Samples      int64       `json:"samples"`
	Wins         int64       `json:"wins"`
	WinRate      interface{} `json:"win_rate"`
	PickRate     interface{} `json:"pick_rate"`
	AvgMmr       float64     `json:"avg_mmr"`
	AvgSurvival  float64     `json:"avg_survival"`
}

func (q *Queries) GetCompMetricsBySelectedCWs(ctx context.Context, arg GetCompMetricsBySelectedCWsParams) (GetCompMetricsBySelectedCWsRow, error) {
	row := q.db.QueryRow(ctx, getCompMetricsBySelectedCWs,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	var i GetCompMetricsBySelectedCWsRow
	err := row.Scan(
		&i.ClusterIds,
		&i.ClusterLabel,
		&i.Samples,
		&i.Wins,
		&i.WinRate,
		&i.PickRate,
		&i.AvgMmr,
		&i.AvgSurvival,
	)
	return i, err
}

const getCwDailyTrend = `-- name: GetCwDailyTrend :many
WITH
    scope AS (
        SELECT
            game_team_id, game_code, started_at, game_rank, total_time, team_avg_mmr, cw_ids, cluster_ids
        FROM
            mv_trio_teams
        WHERE
            (
                started_at >= COALESCE($1::timestamptz, NOW() - INTERVAL '14 days')
                AND started_at < COALESCE($2::timestamptz, NOW())
            )
    ),
    scope_with_tier AS (
        SELECT
            s.game_team_id, s.game_code, s.started_at, s.game_rank, s.total_time, s.team_avg_mmr, s.cw_ids, s.cluster_ids
        FROM
            scope s
            LEFT JOIN tiers t ON s.team_avg_mmr <@ t.mmr_range
        WHERE
            (
                NULLIF($3, '') IS NULL
                OR t.name = $3
            )
    ),
    daily AS (
        SELECT
            DATE_TRUNC('day', started_at) AS DAY,
            COUNT(*) AS team_count,
            SUM((game_rank = 1)::int) AS wins
        FROM
            scope_with_tier
        WHERE
            $4::int = ANY (cw_ids)
        GROUP BY
            1
        HAVING
            COUNT(*) >= COALESCE(NULLIF($5::int, 0), 50)
    ),
    totals AS (
        SELECT
            DATE_TRUNC('day', started_at) AS DAY,
            COUNT(*)::float8 AS total_teams
        FROM
            scope_with_tier
        GROUP BY
            1
    )
SELECT
    d.day,
    d.team_count AS samples,
    COALESCE(
        d.wins::float8 / NULLIF(d.team_count::float8, 0.0),
        0.0
    ) AS win_rate,
    COALESCE(
        d.team_count::float8 / NULLIF(t.total_teams, 0.0),
        0.0
    ) AS pick_rate
FROM
    daily d
    JOIN totals t ON t.day = d.day
ORDER BY
    d.day
`

type GetCwDailyTrendParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 interface{}        `json:"column_3"`
	Column4 int32              `json:"column_4"`
	Column5 int32              `json:"column_5"`
}

type GetCwDailyTrendRow struct {
	Day      pgtype.Interval `json:"day"`
	Samples  int64           `json:"samples"`
	WinRate  interface{}     `json:"win_rate"`
	PickRate interface{}     `json:"pick_rate"`
}

func (q *Queries) GetCwDailyTrend(ctx context.Context, arg GetCwDailyTrendParams) ([]GetCwDailyTrendRow, error) {
	rows, err := q.db.Query(ctx, getCwDailyTrend,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCwDailyTrendRow
	for rows.Next() {
		var i GetCwDailyTrendRow
		if err := rows.Scan(
			&i.Day,
			&i.Samples,
			&i.WinRate,
			&i.PickRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCwStatTop5 = `-- name: GetCwStatTop5 :many
WITH
    scope AS (
        SELECT
            game_team_id, game_code, started_at, game_rank, total_time, team_avg_mmr, cw_ids, cluster_ids
        FROM
            mv_trio_teams
        WHERE
            (
                $1::timestamptz IS NULL
                OR started_at >= $1
            )
            AND (
                $2::timestamptz IS NULL
                OR started_at < $2
            )
    ),
    scope_with_tier AS (
        SELECT
            s.game_team_id, s.game_code, s.started_at, s.game_rank, s.total_time, s.team_avg_mmr, s.cw_ids, s.cluster_ids,
            gt.gained_mmr
        FROM
            scope s
            JOIN game_teams gt ON gt.id = s.game_team_id
            LEFT JOIN tiers t ON s.team_avg_mmr <@ t.mmr_range
        WHERE
            (
                NULLIF($3, '') IS NULL
                OR t.name = $3
            )
    ),
    denom AS (
        SELECT
            COUNT(*)::float8 AS total_teams
        FROM
            scope_with_tier
    ),
    cw_hits AS (
        SELECT
            unnest(cw_ids) AS cw_id,
            COUNT(*) AS team_count,
            SUM((game_rank = 1)::int) AS wins,
            AVG(gained_mmr)::float AS avg_mmr,
            AVG(total_time)::float AS avg_survival
        FROM
            scope_with_tier
        GROUP BY
            1
        HAVING
            COUNT(*) >= COALESCE(NULLIF($4::int, 0), 50)
    ),
    -- ê¸°ì¡´ ì§í ê³ì°(ë³ê²½ ìì)
    base AS (
        SELECT
            h.cw_id, h.team_count, h.wins, h.avg_mmr, h.avg_survival,
            COALESCE(
                h.wins::float8 / NULLIF(h.team_count::float8, 0.0),
                0.0
            ) AS win_rate,
            COALESCE(
                h.team_count::float8 / NULLIF(d.total_teams, 0.0),
                0.0
            ) AS pick_rate
        FROM
            cw_hits h
            CROSS JOIN denom d
    ),
    -- ì ê·í(0~1)ë§ í´ì score ê³ì°ì ì¬ì©
    norm AS (
        SELECT
            b.cw_id, b.team_count, b.wins, b.avg_mmr, b.avg_survival, b.win_rate, b.pick_rate,
            CUME_DIST() OVER (
                ORDER BY
                    b.win_rate
            ) AS wr,
            CUME_DIST() OVER (
                ORDER BY
                    b.avg_mmr
            ) AS mmr_norm,
            CUME_DIST() OVER (
                ORDER BY
                    b.pick_rate
            ) AS pr_raw
        FROM
            base b
    ),
    -- ìµì¢ score (ê°ì¤ì¹/ì ë¢°ë ì ì©)
    scored AS (
        SELECT
            n.cw_id, n.team_count, n.wins, n.avg_mmr, n.avg_survival, n.win_rate, n.pick_rate, n.wr, n.mmr_norm, n.pr_raw,
            sqrt(n.pr_raw) AS pr, -- ì¸ê¸° ê³¼ë ìí¥ ìí
            (1.0 - exp(- (n.team_count::float8) / 200.0)) AS conf, -- íë³¸ ì ë¢°ë
            (
                0.50::float8 * n.wr + 0.30::float8 * n.mmr_norm + 0.20::float8 * sqrt(n.pr_raw)
            ) * (1.0 - exp(- (n.team_count::float8) / 200.0)) AS score -- float8
        FROM
            norm n
    ),
    -- í¼ì¼íì¼ ì»·(í°ì´ ê²½ê³ì¹): S p95, A p80, B p55, C p30
    thresh AS (
        SELECT
            percentile_cont(0.95) WITHIN GROUP (
                ORDER BY
                    score
            ) AS p95, -- S íí
            percentile_cont(0.80) WITHIN GROUP (
                ORDER BY
                    score
            ) AS p80, -- A íí
            percentile_cont(0.55) WITHIN GROUP (
                ORDER BY
                    score
            ) AS p55, -- B íí
            percentile_cont(0.30) WITHIN GROUP (
                ORDER BY
                    score
            ) AS p30 -- C íí
        FROM
            scored
    )
SELECT
    s.cw_id,
    cw.character_id,
    cw.weapon_id,
    cw.position_id,
    cw.cluster_id,
    c.name_kr AS character_name_kr,
    w.name_kr AS weapon_name_kr,
    s.team_count AS samples,
    s.wins,
    s.win_rate, -- ê·¸ëë¡
    s.pick_rate, -- ê·¸ëë¡
    s.avg_mmr, -- ê·¸ëë¡
    s.avg_survival, -- ê·¸ëë¡
    s.score::float8 AS s_score, -- â ì¶ê°(íì íì )
    CASE -- â í°ì´ ë°°ì 
        WHEN s.score >= t.p95 THEN 'S' -- ìì 5%
        WHEN s.score >= t.p80 THEN 'A' -- 80~95%
        WHEN s.score >= t.p55 THEN 'B' -- 55~80%
        WHEN s.score >= t.p30 THEN 'C' -- 30~55%
        ELSE 'D' -- 30% ë¯¸ë§
    END AS tier
FROM
    scored s
    CROSS JOIN thresh t
    JOIN character_weapons cw ON cw.id = s.cw_id
    JOIN characters c ON c.id = cw.character_id
    JOIN weapons w ON w.code = cw.weapon_id
ORDER BY
    s_score DESC
LIMIT
    5
`

type GetCwStatTop5Params struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 interface{}        `json:"column_3"`
	Column4 int32              `json:"column_4"`
}

type GetCwStatTop5Row struct {
	CwID            interface{} `json:"cw_id"`
	CharacterID     int32       `json:"character_id"`
	WeaponID        int32       `json:"weapon_id"`
	PositionID      int32       `json:"position_id"`
	ClusterID       int32       `json:"cluster_id"`
	CharacterNameKr string      `json:"character_name_kr"`
	WeaponNameKr    string      `json:"weapon_name_kr"`
	Samples         int64       `json:"samples"`
	Wins            int64       `json:"wins"`
	WinRate         interface{} `json:"win_rate"`
	PickRate        interface{} `json:"pick_rate"`
	AvgMmr          float64     `json:"avg_mmr"`
	AvgSurvival     float64     `json:"avg_survival"`
	SScore          float64     `json:"s_score"`
	Tier            string      `json:"tier"`
}

func (q *Queries) GetCwStatTop5(ctx context.Context, arg GetCwStatTop5Params) ([]GetCwStatTop5Row, error) {
	rows, err := q.db.Query(ctx, getCwStatTop5,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCwStatTop5Row
	for rows.Next() {
		var i GetCwStatTop5Row
		if err := rows.Scan(
			&i.CwID,
			&i.CharacterID,
			&i.WeaponID,
			&i.PositionID,
			&i.ClusterID,
			&i.CharacterNameKr,
			&i.WeaponNameKr,
			&i.Samples,
			&i.Wins,
			&i.WinRate,
			&i.PickRate,
			&i.AvgMmr,
			&i.AvgSurvival,
			&i.SScore,
			&i.Tier,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCwStats = `-- name: GetCwStats :many
WITH
    scope AS (
        SELECT
            game_team_id, game_code, started_at, game_rank, total_time, team_avg_mmr, cw_ids, cluster_ids
        FROM
            mv_trio_teams
        WHERE
            (
                $1::timestamptz IS NULL
                OR started_at >= $1
            )
            AND (
                $2::timestamptz IS NULL
                OR started_at < $2
            )
    ),
    scope_with_tier AS (
        SELECT
            s.game_team_id, s.game_code, s.started_at, s.game_rank, s.total_time, s.team_avg_mmr, s.cw_ids, s.cluster_ids,
            gt.gained_mmr
        FROM
            scope s
            JOIN game_teams gt ON gt.id = s.game_team_id
            LEFT JOIN tiers t ON s.team_avg_mmr <@ t.mmr_range
        WHERE
            (
                NULLIF($3, '') IS NULL
                OR t.name = $3
            )
    ),
    denom AS (
        SELECT
            COUNT(*)::float8 AS total_teams
        FROM
            scope_with_tier
    ),
    cw_hits AS (
        SELECT
            unnest(cw_ids) AS cw_id,
            COUNT(*) AS team_count,
            SUM((game_rank = 1)::int) AS wins,
            AVG(gained_mmr)::float AS avg_mmr,
            AVG(total_time)::float AS avg_survival
        FROM
            scope_with_tier
        GROUP BY
            1
        HAVING
            COUNT(*) >= COALESCE(NULLIF($4::int, 0), 50)
    ),
    -- ê¸°ì¡´ ì§í ê³ì°(ë³ê²½ ìì)
    base AS (
        SELECT
            h.cw_id, h.team_count, h.wins, h.avg_mmr, h.avg_survival,
            COALESCE(
                h.wins::float8 / NULLIF(h.team_count::float8, 0.0),
                0.0
            ) AS win_rate,
            COALESCE(
                h.team_count::float8 / NULLIF(d.total_teams, 0.0),
                0.0
            ) AS pick_rate
        FROM
            cw_hits h
            CROSS JOIN denom d
    ),
    -- ì ê·í(0~1)ë§ í´ì score ê³ì°ì ì¬ì©
    norm AS (
        SELECT
            b.cw_id, b.team_count, b.wins, b.avg_mmr, b.avg_survival, b.win_rate, b.pick_rate,
            CUME_DIST() OVER (
                ORDER BY
                    b.win_rate
            ) AS wr,
            CUME_DIST() OVER (
                ORDER BY
                    b.avg_mmr
            ) AS mmr_norm,
            CUME_DIST() OVER (
                ORDER BY
                    b.pick_rate
            ) AS pr_raw
        FROM
            base b
    ),
    -- ìµì¢ score (ê°ì¤ì¹/ì ë¢°ë ì ì©)
    scored AS (
        SELECT
            n.cw_id, n.team_count, n.wins, n.avg_mmr, n.avg_survival, n.win_rate, n.pick_rate, n.wr, n.mmr_norm, n.pr_raw,
            sqrt(n.pr_raw) AS pr, -- ì¸ê¸° ê³¼ë ìí¥ ìí
            (1.0 - exp(- (n.team_count::float8) / 200.0)) AS conf, -- íë³¸ ì ë¢°ë
            (
                0.50::float8 * n.wr + 0.30::float8 * n.mmr_norm + 0.20::float8 * sqrt(n.pr_raw)
            ) * (1.0 - exp(- (n.team_count::float8) / 200.0)) AS score -- float8
        FROM
            norm n
    ),
    -- í¼ì¼íì¼ ì»·(í°ì´ ê²½ê³ì¹): S p95, A p80, B p55, C p30
    thresh AS (
        SELECT
            percentile_cont(0.95) WITHIN GROUP (
                ORDER BY
                    score
            ) AS p95, -- S íí
            percentile_cont(0.80) WITHIN GROUP (
                ORDER BY
                    score
            ) AS p80, -- A íí
            percentile_cont(0.55) WITHIN GROUP (
                ORDER BY
                    score
            ) AS p55, -- B íí
            percentile_cont(0.30) WITHIN GROUP (
                ORDER BY
                    score
            ) AS p30 -- C íí
        FROM
            scored
    )
SELECT
    s.cw_id,
    cw.character_id,
    cw.weapon_id,
    cw.position_id,
    cw.cluster_id,
    c.name_kr AS character_name_kr,
    w.name_kr AS weapon_name_kr,
    s.team_count AS samples,
    s.wins,
    s.win_rate, -- ê·¸ëë¡
    s.pick_rate, -- ê·¸ëë¡
    s.avg_mmr, -- ê·¸ëë¡
    s.avg_survival, -- ê·¸ëë¡
    s.score::float8 AS s_score, -- â ì¶ê°(íì íì )
    CASE -- â í°ì´ ë°°ì 
        WHEN s.score >= t.p95 THEN 'S' -- ìì 5%
        WHEN s.score >= t.p80 THEN 'A' -- 80~95%
        WHEN s.score >= t.p55 THEN 'B' -- 55~80%
        WHEN s.score >= t.p30 THEN 'C' -- 30~55%
        ELSE 'D' -- 30% ë¯¸ë§
    END AS tier
FROM
    scored s
    CROSS JOIN thresh t
    JOIN character_weapons cw ON cw.id = s.cw_id
    JOIN characters c ON c.id = cw.character_id
    JOIN weapons w ON w.code = cw.weapon_id
ORDER BY
    s_score DESC
`

type GetCwStatsParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 interface{}        `json:"column_3"`
	Column4 int32              `json:"column_4"`
}

type GetCwStatsRow struct {
	CwID            interface{} `json:"cw_id"`
	CharacterID     int32       `json:"character_id"`
	WeaponID        int32       `json:"weapon_id"`
	PositionID      int32       `json:"position_id"`
	ClusterID       int32       `json:"cluster_id"`
	CharacterNameKr string      `json:"character_name_kr"`
	WeaponNameKr    string      `json:"weapon_name_kr"`
	Samples         int64       `json:"samples"`
	Wins            int64       `json:"wins"`
	WinRate         interface{} `json:"win_rate"`
	PickRate        interface{} `json:"pick_rate"`
	AvgMmr          float64     `json:"avg_mmr"`
	AvgSurvival     float64     `json:"avg_survival"`
	SScore          float64     `json:"s_score"`
	Tier            string      `json:"tier"`
}

func (q *Queries) GetCwStats(ctx context.Context, arg GetCwStatsParams) ([]GetCwStatsRow, error) {
	rows, err := q.db.Query(ctx, getCwStats,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCwStatsRow
	for rows.Next() {
		var i GetCwStatsRow
		if err := rows.Scan(
			&i.CwID,
			&i.CharacterID,
			&i.WeaponID,
			&i.PositionID,
			&i.ClusterID,
			&i.CharacterNameKr,
			&i.WeaponNameKr,
			&i.Samples,
			&i.Wins,
			&i.WinRate,
			&i.PickRate,
			&i.AvgMmr,
			&i.AvgSurvival,
			&i.SScore,
			&i.Tier,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOneCwStats = `-- name: GetOneCwStats :one
WITH
    scope AS (
        SELECT
            game_team_id, game_code, started_at, game_rank, total_time, team_avg_mmr, cw_ids, cluster_ids
        FROM
            mv_trio_teams
        WHERE
            (
                $1::timestamptz IS NULL
                OR started_at >= $1
            )
            AND (
                $2::timestamptz IS NULL
                OR started_at < $2
            )
    ),
    scope_with_tier AS (
        SELECT
            s.game_team_id, s.game_code, s.started_at, s.game_rank, s.total_time, s.team_avg_mmr, s.cw_ids, s.cluster_ids,
            gt.gained_mmr
        FROM
            scope s
            JOIN game_teams gt ON gt.id = s.game_team_id
            LEFT JOIN tiers t ON s.team_avg_mmr <@ t.mmr_range
        WHERE
            (
                NULLIF($3, '') IS NULL
                OR t.name = $3
            )
    ),
    denom AS (
        SELECT
            COUNT(*)::float8 AS total_teams
        FROM
            scope_with_tier
    ),
    hits AS (
        SELECT
            COUNT(*) AS team_count,
            SUM((game_rank = 1)::int) AS wins,
            AVG(gained_mmr)::float AS avg_mmr,
            AVG(total_time)::float AS avg_survival
        FROM
            scope_with_tier
        WHERE
            $4::int = ANY (cw_ids)
    )
SELECT
    cw.id AS cw_id,
    cw.character_id,
    cw.weapon_id,
    c.name_kr AS character_name_kr,
    w.name_kr AS weapon_name_kr,
    h.team_count AS samples,
    h.wins,
    COALESCE(
        h.wins::float8 / NULLIF(h.team_count::float8, 0),
        0.0
    ) AS win_rate,
    COALESCE(
        h.team_count::float8 / NULLIF(d.total_teams, 0.0),
        0.0
    ) AS pick_rate,
    h.avg_mmr,
    h.avg_survival
FROM
    hits h
    CROSS JOIN denom d
    JOIN character_weapons cw ON cw.id = $4
    JOIN characters c ON c.id = cw.character_id
    JOIN weapons w ON w.code = cw.weapon_id
WHERE
    h.team_count >= COALESCE(NULLIF($5::int, 0), 50)
`

type GetOneCwStatsParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 interface{}        `json:"column_3"`
	ID      int32              `json:"id"`
	Column5 int32              `json:"column_5"`
}

type GetOneCwStatsRow struct {
	CwID            int32       `json:"cw_id"`
	CharacterID     int32       `json:"character_id"`
	WeaponID        int32       `json:"weapon_id"`
	CharacterNameKr string      `json:"character_name_kr"`
	WeaponNameKr    string      `json:"weapon_name_kr"`
	Samples         int64       `json:"samples"`
	Wins            int64       `json:"wins"`
	WinRate         interface{} `json:"win_rate"`
	PickRate        interface{} `json:"pick_rate"`
	AvgMmr          float64     `json:"avg_mmr"`
	AvgSurvival     float64     `json:"avg_survival"`
}

func (q *Queries) GetOneCwStats(ctx context.Context, arg GetOneCwStatsParams) (GetOneCwStatsRow, error) {
	row := q.db.QueryRow(ctx, getOneCwStats,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.ID,
		arg.Column5,
	)
	var i GetOneCwStatsRow
	err := row.Scan(
		&i.CwID,
		&i.CharacterID,
		&i.WeaponID,
		&i.CharacterNameKr,
		&i.WeaponNameKr,
		&i.Samples,
		&i.Wins,
		&i.WinRate,
		&i.PickRate,
		&i.AvgMmr,
		&i.AvgSurvival,
	)
	return i, err
}

const getTopClusterCombos = `-- name: GetTopClusterCombos :many
WITH
    scope AS (
        SELECT
            game_team_id, game_code, started_at, game_rank, total_time, team_avg_mmr, cw_ids, cluster_ids
        FROM
            mv_trio_teams
        WHERE
            (
                $1::timestamptz IS NULL
                OR started_at >= $1
            )
            AND (
                $2::timestamptz IS NULL
                OR started_at < $2
            )
    ),
    scope_with_tier AS (
        SELECT
            s.game_team_id, s.game_code, s.started_at, s.game_rank, s.total_time, s.team_avg_mmr, s.cw_ids, s.cluster_ids,
            gt.gained_mmr
        FROM
            scope s
            JOIN game_teams gt ON gt.id = s.game_team_id
            LEFT JOIN tiers t ON s.team_avg_mmr <@ t.mmr_range
        WHERE
            (
                NULLIF($3, '') IS NULL
                OR t.name = $3
            )
    ),
    denom AS (
        SELECT
            COUNT(*)::float8 AS total_teams
        FROM
            scope_with_tier
    ),
    combo AS (
        SELECT
            cluster_ids,
            COUNT(*) AS team_count,
            SUM((game_rank = 1)::int) AS wins,
            AVG(gained_mmr)::float AS avg_mmr, -- â gained_mmr íê· 
            AVG(total_time)::float AS avg_survival
        FROM
            scope_with_tier
        GROUP BY
            cluster_ids
        HAVING
            COUNT(*) >= COALESCE(NULLIF($6::int, 0), 50)
    )
SELECT
    c.cluster_ids,
    ARRAY_TO_STRING(
        ARRAY(
            SELECT
                cu.name
            FROM
                UNNEST(c.cluster_ids) cid
                JOIN clusters cu ON cu.id = cid
            ORDER BY
                cu.name
        ),
        ' Â· '
    ) AS cluster_label,
    c.team_count AS samples,
    c.wins,
    COALESCE(
        c.wins::float8 / NULLIF(c.team_count::float8, 0.0),
        0.0
    ) AS win_rate,
    COALESCE(
        c.team_count::float8 / NULLIF(d.total_teams, 0.0),
        0.0
    ) AS pick_rate,
    c.avg_mmr, -- â gained_mmr íê· 
    c.avg_survival
FROM
    combo c
    CROSS JOIN denom d
ORDER BY
    win_rate DESC
LIMIT
    $4
OFFSET
    $5
`

type GetTopClusterCombosParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 interface{}        `json:"column_3"`
	Limit   int32              `json:"limit"`
	Offset  int32              `json:"offset"`
	Column6 int32              `json:"column_6"`
}

type GetTopClusterCombosRow struct {
	ClusterIds   interface{} `json:"cluster_ids"`
	ClusterLabel string      `json:"cluster_label"`
	Samples      int64       `json:"samples"`
	Wins         int64       `json:"wins"`
	WinRate      interface{} `json:"win_rate"`
	PickRate     interface{} `json:"pick_rate"`
	AvgMmr       float64     `json:"avg_mmr"`
	AvgSurvival  float64     `json:"avg_survival"`
}

// ê¸°ì¡´ ì ë ¬ ì ì§(Top5 ì©ìì  score DESC ë³ë ì¿¼ë¦¬/íë¼ë¯¸í°ë¡)
// ê¸°ì¡´ ì ë ¬ ì ì§(Top5 ì©ì¼ë¡ë ë³ë ì¿¼ë¦¬ìì score DESC ì¬ì©)
func (q *Queries) GetTopClusterCombos(ctx context.Context, arg GetTopClusterCombosParams) ([]GetTopClusterCombosRow, error) {
	rows, err := q.db.Query(ctx, getTopClusterCombos,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
		arg.Column6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopClusterCombosRow
	for rows.Next() {
		var i GetTopClusterCombosRow
		if err := rows.Scan(
			&i.ClusterIds,
			&i.ClusterLabel,
			&i.Samples,
			&i.Wins,
			&i.WinRate,
			&i.PickRate,
			&i.AvgMmr,
			&i.AvgSurvival,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshMvTrioTeams = `-- name: RefreshMvTrioTeams :exec
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_trio_teams
`

func (q *Queries) RefreshMvTrioTeams(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshMvTrioTeams)
	return err
}
