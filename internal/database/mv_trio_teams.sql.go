// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: mv_trio_teams.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCompMetricsBySelectedCWs = `-- name: GetCompMetricsBySelectedCWs :one
WITH
    want AS (
        SELECT
            ARRAY(
                SELECT
                    cw.cluster_id
                FROM
                    character_weapons cw
                WHERE
                    cw.id = ANY ($3::INT[])
                ORDER BY
                    cw.cluster_id
            ) AS cluster_ids
    ),
    scope AS (
        SELECT
            game_team_id, game_code, started_at, game_rank, total_time, team_avg_mmr, cw_ids, cluster_ids
        FROM
            mv_trio_teams
        WHERE
            (
                $1::timestamptz IS NULL
                OR started_at >= $1
            )
            AND (
                $2::timestamptz IS NULL
                OR started_at < $2
            )
    ),
    scope_with_tier AS (
        SELECT
            s.game_team_id, s.game_code, s.started_at, s.game_rank, s.total_time, s.team_avg_mmr, s.cw_ids, s.cluster_ids,
            gt.gained_mmr
        FROM
            scope s
            JOIN game_teams gt ON gt.id = s.game_team_id
            LEFT JOIN tiers t ON s.team_avg_mmr <@ t.mmr_range
        WHERE
            (
                NULLIF($4, '') IS NULL
                OR t.name = $4
            )
    ),
    denom AS (
        SELECT
            COUNT(*)::float8 AS total_teams
        FROM
            scope_with_tier
    ),
    matched AS (
        SELECT
            s.game_team_id, s.game_code, s.started_at, s.game_rank, s.total_time, s.team_avg_mmr, s.cw_ids, s.cluster_ids, s.gained_mmr
        FROM
            scope_with_tier s,
            want w
        WHERE
            s.cluster_ids = w.cluster_ids
    ),
    agg AS (
        SELECT
            COUNT(*) AS team_count,
            SUM((game_rank = 1)::int) AS wins,
            AVG(gained_mmr)::float AS avg_mmr, -- ✅ gained_mmr 평균
            AVG(total_time)::float AS avg_survival
        FROM
            matched
    )
SELECT
    a.team_count AS samples,
    a.wins,
    COALESCE(
        a.wins::float8 / NULLIF(a.team_count::float8, 0.0),
        0.0
    ) AS win_rate,
    COALESCE(
        a.team_count::float8 / NULLIF(d.total_teams, 0.0),
        0.0
    ) AS pick_rate,
    a.avg_mmr, -- ✅ gained_mmr 평균
    a.avg_survival
FROM
    agg a
    CROSS JOIN denom d
WHERE
    a.team_count >= COALESCE(NULLIF($5::int, 0), 50)
`

type GetCompMetricsBySelectedCWsParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 []int32            `json:"column_3"`
	Column4 interface{}        `json:"column_4"`
	Column5 int32              `json:"column_5"`
}

type GetCompMetricsBySelectedCWsRow struct {
	Samples     int64       `json:"samples"`
	Wins        int64       `json:"wins"`
	WinRate     interface{} `json:"win_rate"`
	PickRate    interface{} `json:"pick_rate"`
	AvgMmr      float64     `json:"avg_mmr"`
	AvgSurvival float64     `json:"avg_survival"`
}

func (q *Queries) GetCompMetricsBySelectedCWs(ctx context.Context, arg GetCompMetricsBySelectedCWsParams) (GetCompMetricsBySelectedCWsRow, error) {
	row := q.db.QueryRow(ctx, getCompMetricsBySelectedCWs,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	var i GetCompMetricsBySelectedCWsRow
	err := row.Scan(
		&i.Samples,
		&i.Wins,
		&i.WinRate,
		&i.PickRate,
		&i.AvgMmr,
		&i.AvgSurvival,
	)
	return i, err
}

const getCwDailyTrend = `-- name: GetCwDailyTrend :many
WITH
    scope AS (
        SELECT
            game_team_id, game_code, started_at, game_rank, total_time, team_avg_mmr, cw_ids, cluster_ids
        FROM
            mv_trio_teams
        WHERE
            (
                started_at >= COALESCE($1::timestamptz, NOW() - INTERVAL '14 days')
                AND started_at < COALESCE($2::timestamptz, NOW())
            )
    ),
    scope_with_tier AS (
        SELECT
            s.game_team_id, s.game_code, s.started_at, s.game_rank, s.total_time, s.team_avg_mmr, s.cw_ids, s.cluster_ids
        FROM
            scope s
            LEFT JOIN tiers t ON s.team_avg_mmr <@ t.mmr_range
        WHERE
            (
                NULLIF($3, '') IS NULL
                OR t.name = $3
            )
    ),
    daily AS (
        SELECT
            DATE_TRUNC('day', started_at) AS DAY,
            COUNT(*) AS team_count,
            SUM((game_rank = 1)::int) AS wins
        FROM
            scope_with_tier
        WHERE
            $4::int = ANY (cw_ids)
        GROUP BY
            1
        HAVING
            COUNT(*) >= COALESCE(NULLIF($5::int, 0), 50)
    ),
    totals AS (
        SELECT
            DATE_TRUNC('day', started_at) AS DAY,
            COUNT(*)::float8 AS total_teams
        FROM
            scope_with_tier
        GROUP BY
            1
    )
SELECT
    d.day,
    d.team_count AS samples,
    COALESCE(
        d.wins::float8 / NULLIF(d.team_count::float8, 0.0),
        0.0
    ) AS win_rate,
    COALESCE(
        d.team_count::float8 / NULLIF(t.total_teams, 0.0),
        0.0
    ) AS pick_rate
FROM
    daily d
    JOIN totals t ON t.day = d.day
ORDER BY
    d.day
`

type GetCwDailyTrendParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 interface{}        `json:"column_3"`
	Column4 int32              `json:"column_4"`
	Column5 int32              `json:"column_5"`
}

type GetCwDailyTrendRow struct {
	Day      pgtype.Interval `json:"day"`
	Samples  int64           `json:"samples"`
	WinRate  interface{}     `json:"win_rate"`
	PickRate interface{}     `json:"pick_rate"`
}

func (q *Queries) GetCwDailyTrend(ctx context.Context, arg GetCwDailyTrendParams) ([]GetCwDailyTrendRow, error) {
	rows, err := q.db.Query(ctx, getCwDailyTrend,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCwDailyTrendRow
	for rows.Next() {
		var i GetCwDailyTrendRow
		if err := rows.Scan(
			&i.Day,
			&i.Samples,
			&i.WinRate,
			&i.PickRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCwStats = `-- name: GetCwStats :many
WITH
    scope AS (
        SELECT
            game_team_id, game_code, started_at, game_rank, total_time, team_avg_mmr, cw_ids, cluster_ids
        FROM
            mv_trio_teams
        WHERE
            (
                $1::timestamptz IS NULL
                OR started_at >= $1
            )
            AND (
                $2::timestamptz IS NULL
                OR started_at < $2
            )
    ),
    scope_with_tier AS (
        SELECT
            s.game_team_id, s.game_code, s.started_at, s.game_rank, s.total_time, s.team_avg_mmr, s.cw_ids, s.cluster_ids,
            gt.gained_mmr
        FROM
            scope s
            JOIN game_teams gt ON gt.id = s.game_team_id
            LEFT JOIN tiers t ON s.team_avg_mmr <@ t.mmr_range
        WHERE
            (
                NULLIF($3, '') IS NULL
                OR t.name = $3
            )
    ),
    denom AS (
        SELECT
            COUNT(*)::float8 AS total_teams
        FROM
            scope_with_tier
    ),
    cw_hits AS (
        SELECT
            unnest(cw_ids) AS cw_id,
            COUNT(*) AS team_count,
            SUM((game_rank = 1)::int) AS wins,
            AVG(gained_mmr)::float AS avg_mmr, -- ✅ gained_mmr 평균
            AVG(total_time)::float AS avg_survival
        FROM
            scope_with_tier
        GROUP BY
            1
        HAVING
            COUNT(*) >= COALESCE(NULLIF($4::int, 0), 50)
    )
SELECT
    h.cw_id,
    -- ✅ ID 대신 이름을 내려줌
    c.name_kr AS character_name_kr,
    w.name_kr AS weapon_name_kr,
    cw.position_id,
    cw.cluster_id,
    h.team_count AS samples,
    h.wins,
    COALESCE(
        h.wins::float8 / NULLIF(h.team_count::float8, 0.0),
        0.0
    ) AS win_rate,
    COALESCE(
        h.team_count::float8 / NULLIF(d.total_teams, 0.0),
        0.0
    ) AS pick_rate,
    h.avg_mmr, -- gained_mmr 평균
    h.avg_survival
FROM
    cw_hits h
    JOIN character_weapons cw ON cw.id = h.cw_id
    JOIN characters c ON c.id = cw.character_id -- ✅ 이름 조인
    JOIN weapons w ON w.code = cw.weapon_id -- ✅ 이름 조인
    CROSS JOIN denom d
ORDER BY
    win_rate DESC
`

type GetCwStatsParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 interface{}        `json:"column_3"`
	Column4 int32              `json:"column_4"`
}

type GetCwStatsRow struct {
	CwID            interface{} `json:"cw_id"`
	CharacterNameKr string      `json:"character_name_kr"`
	WeaponNameKr    string      `json:"weapon_name_kr"`
	PositionID      int32       `json:"position_id"`
	ClusterID       int32       `json:"cluster_id"`
	Samples         int64       `json:"samples"`
	Wins            int64       `json:"wins"`
	WinRate         interface{} `json:"win_rate"`
	PickRate        interface{} `json:"pick_rate"`
	AvgMmr          float64     `json:"avg_mmr"`
	AvgSurvival     float64     `json:"avg_survival"`
}

func (q *Queries) GetCwStats(ctx context.Context, arg GetCwStatsParams) ([]GetCwStatsRow, error) {
	rows, err := q.db.Query(ctx, getCwStats,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCwStatsRow
	for rows.Next() {
		var i GetCwStatsRow
		if err := rows.Scan(
			&i.CwID,
			&i.CharacterNameKr,
			&i.WeaponNameKr,
			&i.PositionID,
			&i.ClusterID,
			&i.Samples,
			&i.Wins,
			&i.WinRate,
			&i.PickRate,
			&i.AvgMmr,
			&i.AvgSurvival,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopClusterCombos = `-- name: GetTopClusterCombos :many
WITH
    scope AS (
        SELECT
            game_team_id, game_code, started_at, game_rank, total_time, team_avg_mmr, cw_ids, cluster_ids
        FROM
            mv_trio_teams
        WHERE
            (
                $1::timestamptz IS NULL
                OR started_at >= $1
            )
            AND (
                $2::timestamptz IS NULL
                OR started_at < $2
            )
    ),
    scope_with_tier AS (
        SELECT
            s.game_team_id, s.game_code, s.started_at, s.game_rank, s.total_time, s.team_avg_mmr, s.cw_ids, s.cluster_ids,
            gt.gained_mmr
        FROM
            scope s
            JOIN game_teams gt ON gt.id = s.game_team_id
            LEFT JOIN tiers t ON s.team_avg_mmr <@ t.mmr_range
        WHERE
            (
                NULLIF($3, '') IS NULL
                OR t.name = $3
            )
    ),
    denom AS (
        SELECT
            COUNT(*)::float8 AS total_teams
        FROM
            scope_with_tier
    ),
    combo AS (
        SELECT
            cluster_ids,
            COUNT(*) AS team_count,
            SUM((game_rank = 1)::int) AS wins,
            AVG(gained_mmr)::float AS avg_mmr, -- ✅ gained_mmr 평균
            AVG(total_time)::float AS avg_survival
        FROM
            scope_with_tier
        GROUP BY
            cluster_ids
        HAVING
            COUNT(*) >= COALESCE(NULLIF($6::int, 0), 50)
    )
SELECT
    c.cluster_ids,
    ARRAY_TO_STRING(
        ARRAY(
            SELECT
                cu.name
            FROM
                UNNEST(c.cluster_ids) cid
                JOIN clusters cu ON cu.id = cid
            ORDER BY
                cu.name
        ),
        ' · '
    ) AS cluster_label,
    c.team_count AS samples,
    c.wins,
    COALESCE(
        c.wins::float8 / NULLIF(c.team_count::float8, 0.0),
        0.0
    ) AS win_rate,
    COALESCE(
        c.team_count::float8 / NULLIF(d.total_teams, 0.0),
        0.0
    ) AS pick_rate,
    c.avg_mmr, -- ✅ gained_mmr 평균
    c.avg_survival
FROM
    combo c
    CROSS JOIN denom d
ORDER BY
    win_rate DESC
LIMIT
    $4
OFFSET
    $5
`

type GetTopClusterCombosParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 interface{}        `json:"column_3"`
	Limit   int32              `json:"limit"`
	Offset  int32              `json:"offset"`
	Column6 int32              `json:"column_6"`
}

type GetTopClusterCombosRow struct {
	ClusterIds   interface{} `json:"cluster_ids"`
	ClusterLabel string      `json:"cluster_label"`
	Samples      int64       `json:"samples"`
	Wins         int64       `json:"wins"`
	WinRate      interface{} `json:"win_rate"`
	PickRate     interface{} `json:"pick_rate"`
	AvgMmr       float64     `json:"avg_mmr"`
	AvgSurvival  float64     `json:"avg_survival"`
}

func (q *Queries) GetTopClusterCombos(ctx context.Context, arg GetTopClusterCombosParams) ([]GetTopClusterCombosRow, error) {
	rows, err := q.db.Query(ctx, getTopClusterCombos,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
		arg.Column6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopClusterCombosRow
	for rows.Next() {
		var i GetTopClusterCombosRow
		if err := rows.Scan(
			&i.ClusterIds,
			&i.ClusterLabel,
			&i.Samples,
			&i.Wins,
			&i.WinRate,
			&i.PickRate,
			&i.AvgMmr,
			&i.AvgSurvival,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshMvTrioTeams = `-- name: RefreshMvTrioTeams :exec
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_trio_teams
`

func (q *Queries) RefreshMvTrioTeams(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshMvTrioTeams)
	return err
}
