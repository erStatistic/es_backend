// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: aggregation.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCWMetrics = `-- name: GetCWMetrics :many
WITH
    scope AS (
        SELECT
            m.game_team_id, m.started_at, m.game_rank, m.gained_mmr, m.team_avg_mmr, m.total_time, m.cw_ids, m.cluster_ids
        FROM
            mv_trio_teams m
        WHERE
            (
                $1::timestamptz IS NULL
                OR m.started_at >= $1
            )
            AND (
                $2::timestamptz IS NULL
                OR m.started_at < $2
            )
    ),
    scope_with_tier AS (
        SELECT
            s.game_team_id, s.started_at, s.game_rank, s.gained_mmr, s.team_avg_mmr, s.total_time, s.cw_ids, s.cluster_ids
        FROM
            scope s
            LEFT JOIN tiers t ON s.team_avg_mmr <@ t.mmr_range
        WHERE
            (
                $3::text IS NULL
                OR t.name = $3
            )
    ),
    denom AS (
        SELECT
            COUNT(*) AS total_teams
        FROM
            scope_with_tier
    ),
    cw_hits AS (
        SELECT
            unnest(cw_ids) AS cw_id,
            COUNT(*) AS team_count,
            COUNT(*) FILTER (
                WHERE
                    game_rank = 1
            ) AS win_count,
            AVG(gained_mmr)::float8 AS avg_gained_mmr,
            AVG(total_time)::float8 AS avg_survival_sec
        FROM
            scope_with_tier
        GROUP BY
            1
    )
SELECT
    cw_id,
    (win_count::float8 / NULLIF(team_count, 0)) AS win_rate,
    (team_count::float8 / NULLIF(d.total_teams, 0)) AS pick_rate,
    avg_gained_mmr,
    avg_survival_sec,
    team_count AS samples
FROM
    cw_hits cwh
    CROSS JOIN denom d
ORDER BY
    pick_rate DESC NULLS LAST
LIMIT
    COALESCE($4::int, 200)
`

type GetCWMetricsParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 string             `json:"column_3"`
	Column4 int32              `json:"column_4"`
}

type GetCWMetricsRow struct {
	CwID           interface{} `json:"cw_id"`
	WinRate        int32       `json:"win_rate"`
	PickRate       int32       `json:"pick_rate"`
	AvgGainedMmr   float64     `json:"avg_gained_mmr"`
	AvgSurvivalSec float64     `json:"avg_survival_sec"`
	Samples        int64       `json:"samples"`
}

func (q *Queries) GetCWMetrics(ctx context.Context, arg GetCWMetricsParams) ([]GetCWMetricsRow, error) {
	rows, err := q.db.Query(ctx, getCWMetrics,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCWMetricsRow
	for rows.Next() {
		var i GetCWMetricsRow
		if err := rows.Scan(
			&i.CwID,
			&i.WinRate,
			&i.PickRate,
			&i.AvgGainedMmr,
			&i.AvgSurvivalSec,
			&i.Samples,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClusterCompMetrics = `-- name: GetClusterCompMetrics :many
WITH
    scope AS (
        SELECT
            m.game_team_id, m.started_at, m.game_rank, m.gained_mmr, m.team_avg_mmr, m.total_time, m.cw_ids, m.cluster_ids
        FROM
            mv_trio_teams m
        WHERE
            (
                $1::timestamptz IS NULL
                OR m.started_at >= $1
            )
            AND (
                $2::timestamptz IS NULL
                OR m.started_at < $2
            )
    ),
    scope_with_tier AS (
        SELECT
            s.game_team_id, s.started_at, s.game_rank, s.gained_mmr, s.team_avg_mmr, s.total_time, s.cw_ids, s.cluster_ids
        FROM
            scope s
            LEFT JOIN tiers t ON s.team_avg_mmr <@ t.mmr_range
        WHERE
            (
                $3::text IS NULL
                OR t.name = $3
            )
    ),
    denom AS (
        SELECT
            COUNT(*) AS total_teams
        FROM
            scope_with_tier
    ),
    combo AS (
        SELECT
            cluster_ids,
            COUNT(*) AS games,
            COUNT(*) FILTER (
                WHERE
                    game_rank = 1
            ) AS wins,
            AVG(team_avg_mmr)::float8 AS avg_team_mmr,
            AVG(total_time)::float8 AS avg_survival_sec
        FROM
            scope_with_tier
        GROUP BY
            cluster_ids
    ),
    scored AS (
        SELECT
            cluster_ids,
            games,
            wins,
            avg_team_mmr,
            avg_survival_sec,
            (wins::float8 / NULLIF(games, 0)) AS win_rate,
            (games::float8 / NULLIF(d.total_teams, 0)) AS pick_rate
        FROM
            combo c
            CROSS JOIN denom d
    )
SELECT
    cluster_ids, games, wins, avg_team_mmr, avg_survival_sec, win_rate, pick_rate
FROM
    scored
ORDER BY
    CASE
        WHEN $4::text = 'win_rate' THEN win_rate
    END DESC NULLS LAST,
    CASE
        WHEN $4::text = 'pick_rate' THEN pick_rate
    END DESC NULLS LAST,
    games DESC
LIMIT
    COALESCE($5::int, 200)
`

type GetClusterCompMetricsParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 string             `json:"column_3"`
	Column4 string             `json:"column_4"`
	Column5 int32              `json:"column_5"`
}

type GetClusterCompMetricsRow struct {
	ClusterIds     interface{} `json:"cluster_ids"`
	Games          int64       `json:"games"`
	Wins           int64       `json:"wins"`
	AvgTeamMmr     float64     `json:"avg_team_mmr"`
	AvgSurvivalSec float64     `json:"avg_survival_sec"`
	WinRate        int32       `json:"win_rate"`
	PickRate       int32       `json:"pick_rate"`
}

func (q *Queries) GetClusterCompMetrics(ctx context.Context, arg GetClusterCompMetricsParams) ([]GetClusterCompMetricsRow, error) {
	rows, err := q.db.Query(ctx, getClusterCompMetrics,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClusterCompMetricsRow
	for rows.Next() {
		var i GetClusterCompMetricsRow
		if err := rows.Scan(
			&i.ClusterIds,
			&i.Games,
			&i.Wins,
			&i.AvgTeamMmr,
			&i.AvgSurvivalSec,
			&i.WinRate,
			&i.PickRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTriCompletionSuggestions = `-- name: GetTriCompletionSuggestions :many
WITH
    scope AS (
        SELECT
            m.game_team_id, m.started_at, m.game_rank, m.gained_mmr, m.team_avg_mmr, m.total_time, m.cw_ids, m.cluster_ids
        FROM
            mv_trio_teams m
        WHERE
            (
                $1::timestamptz IS NULL
                OR m.started_at >= $1
            )
            AND (
                $2::timestamptz IS NULL
                OR m.started_at < $2
            )
    ),
    scope_with_tier AS (
        SELECT
            s.game_team_id, s.started_at, s.game_rank, s.gained_mmr, s.team_avg_mmr, s.total_time, s.cw_ids, s.cluster_ids
        FROM
            scope s
            LEFT JOIN tiers t ON s.team_avg_mmr <@ t.mmr_range
        WHERE
            (
                $3::text IS NULL
                OR t.name = $3
            )
    ),
    denom AS (
        SELECT
            COUNT(*) AS total_teams
        FROM
            scope_with_tier
    ),
    cand AS (
        SELECT
            game_team_id, started_at, game_rank, gained_mmr, team_avg_mmr, total_time, cw_ids, cluster_ids
        FROM
            scope_with_tier
        WHERE
            cw_ids @> $4::INT[] -- 선택한 CW들을 모두 포함
    ),
    grouped AS (
        SELECT
            cw_ids,
            COUNT(*) AS games,
            COUNT(*) FILTER (
                WHERE
                    game_rank = 1
            ) AS wins,
            AVG(gained_mmr)::float8 AS avg_gained_mmr,
            AVG(team_avg_mmr)::float8 AS avg_team_mmr,
            AVG(total_time)::float8 AS avg_survival_sec
        FROM
            cand
        GROUP BY
            cw_ids
    ),
    scored AS (
        SELECT
            g.cw_ids, g.games, g.wins, g.avg_gained_mmr, g.avg_team_mmr, g.avg_survival_sec,
            (wins::float8 / NULLIF(games, 0)) AS win_rate,
            (games::float8 / NULLIF(d.total_teams, 0)) AS pick_rate,
            avg_gained_mmr AS mmr_gain
        FROM
            grouped g
            CROSS JOIN denom d
    )
SELECT
    cw_ids, games, wins, avg_gained_mmr, avg_team_mmr, avg_survival_sec, win_rate, pick_rate, mmr_gain
FROM
    scored
ORDER BY
    CASE
        WHEN $5::text = 'win_rate' THEN win_rate
    END DESC NULLS LAST,
    CASE
        WHEN $5::text = 'pick_rate' THEN pick_rate
    END DESC NULLS LAST,
    CASE
        WHEN $5::text = 'mmr_gain' THEN mmr_gain
    END DESC NULLS LAST,
    games DESC
LIMIT
    COALESCE($6::int, 4)
`

type GetTriCompletionSuggestionsParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 string             `json:"column_3"`
	Column4 []int32            `json:"column_4"`
	Column5 string             `json:"column_5"`
	Column6 int32              `json:"column_6"`
}

type GetTriCompletionSuggestionsRow struct {
	CwIds          interface{} `json:"cw_ids"`
	Games          int64       `json:"games"`
	Wins           int64       `json:"wins"`
	AvgGainedMmr   float64     `json:"avg_gained_mmr"`
	AvgTeamMmr     float64     `json:"avg_team_mmr"`
	AvgSurvivalSec float64     `json:"avg_survival_sec"`
	WinRate        int32       `json:"win_rate"`
	PickRate       int32       `json:"pick_rate"`
	MmrGain        float64     `json:"mmr_gain"`
}

func (q *Queries) GetTriCompletionSuggestions(ctx context.Context, arg GetTriCompletionSuggestionsParams) ([]GetTriCompletionSuggestionsRow, error) {
	rows, err := q.db.Query(ctx, getTriCompletionSuggestions,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTriCompletionSuggestionsRow
	for rows.Next() {
		var i GetTriCompletionSuggestionsRow
		if err := rows.Scan(
			&i.CwIds,
			&i.Games,
			&i.Wins,
			&i.AvgGainedMmr,
			&i.AvgTeamMmr,
			&i.AvgSurvivalSec,
			&i.WinRate,
			&i.PickRate,
			&i.MmrGain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTriExactMetrics = `-- name: GetTriExactMetrics :one
WITH
    scope AS (
        SELECT
            m.game_team_id, m.started_at, m.game_rank, m.gained_mmr, m.team_avg_mmr, m.total_time, m.cw_ids, m.cluster_ids
        FROM
            mv_trio_teams m
        WHERE
            (
                $1::timestamptz IS NULL
                OR m.started_at >= $1
            )
            AND (
                $2::timestamptz IS NULL
                OR m.started_at < $2
            )
    ),
    scope_with_tier AS (
        SELECT
            s.game_team_id, s.started_at, s.game_rank, s.gained_mmr, s.team_avg_mmr, s.total_time, s.cw_ids, s.cluster_ids
        FROM
            scope s
            LEFT JOIN tiers t ON s.team_avg_mmr <@ t.mmr_range
        WHERE
            (
                $3::text IS NULL
                OR t.name = $3
            )
    ),
    exact AS (
        SELECT
            game_team_id, started_at, game_rank, gained_mmr, team_avg_mmr, total_time, cw_ids, cluster_ids
        FROM
            scope_with_tier
        WHERE
            cw_ids = (
                SELECT
                    ARRAY(
                        SELECT
                            unnest($4::INT[])
                        ORDER BY
                            1
                    )
            )
    ),
    agg AS (
        SELECT
            COUNT(*) AS games,
            COUNT(*) FILTER (
                WHERE
                    game_rank = 1
            ) AS wins,
            AVG(team_avg_mmr)::float8 AS avg_team_mmr,
            AVG(gained_mmr)::float8 AS avg_gained_mmr,
            AVG(total_time)::float8 AS avg_survival_sec
        FROM
            exact
    )
SELECT
    (wins::float8 / NULLIF(games, 0)) AS win_rate,
    games,
    avg_team_mmr,
    avg_gained_mmr,
    avg_survival_sec
FROM
    agg
`

type GetTriExactMetricsParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 string             `json:"column_3"`
	Column4 []int32            `json:"column_4"`
}

type GetTriExactMetricsRow struct {
	WinRate        int32   `json:"win_rate"`
	Games          int64   `json:"games"`
	AvgTeamMmr     float64 `json:"avg_team_mmr"`
	AvgGainedMmr   float64 `json:"avg_gained_mmr"`
	AvgSurvivalSec float64 `json:"avg_survival_sec"`
}

func (q *Queries) GetTriExactMetrics(ctx context.Context, arg GetTriExactMetricsParams) (GetTriExactMetricsRow, error) {
	row := q.db.QueryRow(ctx, getTriExactMetrics,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var i GetTriExactMetricsRow
	err := row.Scan(
		&i.WinRate,
		&i.Games,
		&i.AvgTeamMmr,
		&i.AvgGainedMmr,
		&i.AvgSurvivalSec,
	)
	return i, err
}
