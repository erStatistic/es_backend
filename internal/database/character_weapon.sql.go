// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: character_weapon.sql

package database

import (
	"context"
)

const cWByCharacterIDAndWeaponID = `-- name: CWByCharacterIDAndWeaponID :one
SELECT
    id, character_id, weapon_id, position_id, cluster_id, created_at, updated_at
FROM
    character_weapons
WHERE
    character_id = $1
    AND weapon_id = $2
`

type CWByCharacterIDAndWeaponIDParams struct {
	CharacterID int32 `json:"character_id"`
	WeaponID    int32 `json:"weapon_id"`
}

func (q *Queries) CWByCharacterIDAndWeaponID(ctx context.Context, arg CWByCharacterIDAndWeaponIDParams) (CharacterWeapon, error) {
	row := q.db.QueryRow(ctx, cWByCharacterIDAndWeaponID, arg.CharacterID, arg.WeaponID)
	var i CharacterWeapon
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.WeaponID,
		&i.PositionID,
		&i.ClusterID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCharacterWeapon = `-- name: CreateCharacterWeapon :one
INSERT INTO
    character_weapons (character_id, weapon_id, position_id, cluster_id)
VALUES
    ($1, $2, $3, $4)
RETURNING
    id, character_id, weapon_id, position_id, cluster_id, created_at, updated_at
`

type CreateCharacterWeaponParams struct {
	CharacterID int32 `json:"character_id"`
	WeaponID    int32 `json:"weapon_id"`
	PositionID  int32 `json:"position_id"`
	ClusterID   int32 `json:"cluster_id"`
}

func (q *Queries) CreateCharacterWeapon(ctx context.Context, arg CreateCharacterWeaponParams) (CharacterWeapon, error) {
	row := q.db.QueryRow(ctx, createCharacterWeapon,
		arg.CharacterID,
		arg.WeaponID,
		arg.PositionID,
		arg.ClusterID,
	)
	var i CharacterWeapon
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.WeaponID,
		&i.PositionID,
		&i.ClusterID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCharacterWeapon = `-- name: DeleteCharacterWeapon :exec
DELETE FROM character_weapons
WHERE
    id = $1
`

func (q *Queries) DeleteCharacterWeapon(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCharacterWeapon, id)
	return err
}

const getCharacterWeapon = `-- name: GetCharacterWeapon :one
SELECT
    id, character_id, weapon_id, position_id, cluster_id, created_at, updated_at
FROM
    character_weapons
WHERE
    id = $1
`

func (q *Queries) GetCharacterWeapon(ctx context.Context, id int32) (CharacterWeapon, error) {
	row := q.db.QueryRow(ctx, getCharacterWeapon, id)
	var i CharacterWeapon
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.WeaponID,
		&i.PositionID,
		&i.ClusterID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCwIdentity = `-- name: GetCwIdentity :one
SELECT
    cw.id AS cw_id,
    c.id AS ch_id,
    c.name_kr AS ch_name,
    COALESCE(c.image_url_mini, COALESCE(c.image_url_full, '')) AS ch_img,
    w.code AS w_code,
    w.name_kr AS w_name,
    COALESCE(w.image_url, '') AS w_img,
    p.id AS p_id,
    p.name AS p_name,
    cu.id AS cluster_id,
    cu.name AS cluster_name
FROM
    character_weapons cw
    JOIN characters c ON c.id = cw.character_id
    JOIN weapons w ON w.code = cw.weapon_id
    JOIN positions p ON p.id = cw.position_id
    JOIN clusters cu ON cu.id = cw.cluster_id
WHERE
    cw.id = $1
`

type GetCwIdentityRow struct {
	CwID        int32  `json:"cw_id"`
	ChID        int32  `json:"ch_id"`
	ChName      string `json:"ch_name"`
	ChImg       string `json:"ch_img"`
	WCode       int32  `json:"w_code"`
	WName       string `json:"w_name"`
	WImg        string `json:"w_img"`
	PID         int32  `json:"p_id"`
	PName       string `json:"p_name"`
	ClusterID   int32  `json:"cluster_id"`
	ClusterName string `json:"cluster_name"`
}

func (q *Queries) GetCwIdentity(ctx context.Context, id int32) (GetCwIdentityRow, error) {
	row := q.db.QueryRow(ctx, getCwIdentity, id)
	var i GetCwIdentityRow
	err := row.Scan(
		&i.CwID,
		&i.ChID,
		&i.ChName,
		&i.ChImg,
		&i.WCode,
		&i.WName,
		&i.WImg,
		&i.PID,
		&i.PName,
		&i.ClusterID,
		&i.ClusterName,
	)
	return i, err
}

const listCharacterWeapons = `-- name: ListCharacterWeapons :many
SELECT
    id, character_id, weapon_id, position_id, cluster_id, created_at, updated_at
FROM
    character_weapons
ORDER BY
    id ASC
`

func (q *Queries) ListCharacterWeapons(ctx context.Context) ([]CharacterWeapon, error) {
	rows, err := q.db.Query(ctx, listCharacterWeapons)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CharacterWeapon
	for rows.Next() {
		var i CharacterWeapon
		if err := rows.Scan(
			&i.ID,
			&i.CharacterID,
			&i.WeaponID,
			&i.PositionID,
			&i.ClusterID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCwByClusterID = `-- name: ListCwByClusterID :many
SELECT
    cw.id AS cw_id,
    ch.id AS ch_id,
    ch.name_kr AS ch_name,
    ch.image_url_mini AS ch_img_mini,
    ch.image_url_full AS ch_img_full,
    w.code AS w_code,
    w.name_kr AS w_name,
    w.image_url AS w_img,
    p.id AS p_id,
    p.name AS p_name
FROM
    character_weapons cw
    JOIN characters ch ON ch.id = cw.character_id
    JOIN weapons w ON w.code = cw.weapon_id -- ⭐ 여기!
    JOIN positions p ON p.id = cw.position_id -- NOT NULL이면 LEFT 필요 없음
WHERE
    cw.cluster_id = $1
ORDER BY
    ch.name_kr,
    w.name_kr
`

type ListCwByClusterIDRow struct {
	CwID      int32  `json:"cw_id"`
	ChID      int32  `json:"ch_id"`
	ChName    string `json:"ch_name"`
	ChImgMini string `json:"ch_img_mini"`
	ChImgFull string `json:"ch_img_full"`
	WCode     int32  `json:"w_code"`
	WName     string `json:"w_name"`
	WImg      string `json:"w_img"`
	PID       int32  `json:"p_id"`
	PName     string `json:"p_name"`
}

func (q *Queries) ListCwByClusterID(ctx context.Context, clusterID int32) ([]ListCwByClusterIDRow, error) {
	rows, err := q.db.Query(ctx, listCwByClusterID, clusterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCwByClusterIDRow
	for rows.Next() {
		var i ListCwByClusterIDRow
		if err := rows.Scan(
			&i.CwID,
			&i.ChID,
			&i.ChName,
			&i.ChImgMini,
			&i.ChImgFull,
			&i.WCode,
			&i.WName,
			&i.WImg,
			&i.PID,
			&i.PName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCwDirectoryByCluster = `-- name: ListCwDirectoryByCluster :many
WITH
    cnts AS (
        SELECT
            cluster_id,
            COUNT(*) AS cws,
            COUNT(DISTINCT character_id) AS characters
        FROM
            character_weapons
        GROUP BY
            cluster_id
    ),
    bypos AS (
        SELECT
            cluster_id,
            position_id,
            COUNT(*) AS n
        FROM
            character_weapons
        GROUP BY
            cluster_id,
            position_id
    ),
    maxn AS (
        SELECT
            cluster_id,
            MAX(n) AS max_n
        FROM
            bypos
        GROUP BY
            cluster_id
    ),
    pick AS (
        SELECT
            b.cluster_id,
            MIN(b.position_id) AS position_id
        FROM
            bypos b
            JOIN maxn m ON m.cluster_id = b.cluster_id
            AND m.max_n = b.n
        GROUP BY
            b.cluster_id
    )
SELECT
    c.id AS cluster_id,
    c.name AS label,
    p.name AS role,
    cnts.cws,
    cnts.characters
FROM
    clusters c
    JOIN cnts ON cnts.cluster_id = c.id
    LEFT JOIN pick pk ON pk.cluster_id = c.id
    LEFT JOIN positions p ON p.id = pk.position_id
ORDER BY
    c.name
`

type ListCwDirectoryByClusterRow struct {
	ClusterID  int32   `json:"cluster_id"`
	Label      string  `json:"label"`
	Role       *string `json:"role"`
	Cws        int64   `json:"cws"`
	Characters int64   `json:"characters"`
}

func (q *Queries) ListCwDirectoryByCluster(ctx context.Context) ([]ListCwDirectoryByClusterRow, error) {
	rows, err := q.db.Query(ctx, listCwDirectoryByCluster)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCwDirectoryByClusterRow
	for rows.Next() {
		var i ListCwDirectoryByClusterRow
		if err := rows.Scan(
			&i.ClusterID,
			&i.Label,
			&i.Role,
			&i.Cws,
			&i.Characters,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCwsByCharacterID = `-- name: ListCwsByCharacterID :many
SELECT
    cw.id AS cw_id,
    w.code AS weapon_code,
    w.name_kr AS weapon_name,
    COALESCE(w.image_url, '') AS weapon_image_url
FROM
    character_weapons cw
    JOIN weapons w ON w.code = cw.weapon_id
WHERE
    cw.character_id = $1
ORDER BY
    w.name_kr
`

type ListCwsByCharacterIDRow struct {
	CwID           int32  `json:"cw_id"`
	WeaponCode     int32  `json:"weapon_code"`
	WeaponName     string `json:"weapon_name"`
	WeaponImageUrl string `json:"weapon_image_url"`
}

// db/queries/character_weapons.sql
// 캐릭터가 가진 CW(무기군) 목록
func (q *Queries) ListCwsByCharacterID(ctx context.Context, characterID int32) ([]ListCwsByCharacterIDRow, error) {
	rows, err := q.db.Query(ctx, listCwsByCharacterID, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCwsByCharacterIDRow
	for rows.Next() {
		var i ListCwsByCharacterIDRow
		if err := rows.Scan(
			&i.CwID,
			&i.WeaponCode,
			&i.WeaponName,
			&i.WeaponImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const patchCharacterWeapon = `-- name: PatchCharacterWeapon :exec
UPDATE character_weapons
SET
    character_id = $2,
    weapon_id = $3,
    position_id = $4,
    cluster_id = $5
WHERE
    id = $1
`

type PatchCharacterWeaponParams struct {
	ID          int32 `json:"id"`
	CharacterID int32 `json:"character_id"`
	WeaponID    int32 `json:"weapon_id"`
	PositionID  int32 `json:"position_id"`
	ClusterID   int32 `json:"cluster_id"`
}

func (q *Queries) PatchCharacterWeapon(ctx context.Context, arg PatchCharacterWeaponParams) error {
	_, err := q.db.Exec(ctx, patchCharacterWeapon,
		arg.ID,
		arg.CharacterID,
		arg.WeaponID,
		arg.PositionID,
		arg.ClusterID,
	)
	return err
}
